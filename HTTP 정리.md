## IP 인터넷 프로토콜

### 역할
* 지정한 IP주소에 데이터 전달
* 패킷(Packet)이라는 통신 단위로 데이터를 전달한다

* IP 패킷 정보
- 패킷은 전송하고자 하는 데이터의 한 블록(payload)과 주소지 정보(발신지 주소, 목적지 주소), 관리정보(Header, IPv6와 같이 망이 패킷을 목적지까지 전달하는데 필요한)로 구성된다. 

### 한계
* 비연결성 : 패킷을 받을 수 없거나 서비스 불능 상태여도 패킷 전송
* 비신뢰성 : 패킷이 중간에 사라지거나 / 순서대로 오지 않을 경우(보낼 데이터가 크면 두개로 끊어서 보냄)
* 프로그램 구분 : 같은 IP를 사용하느 ㄴ서버에서 통신하는 애플리케이션이 둘 이상일 경우(게임, 영화를 같이 하는 경우)

## TCP/UDP

* 프로토콜 계층
![image](https://user-images.githubusercontent.com/97269799/224468234-504d473d-390f-4742-a4db-4fc6ff4fdafb.png)

* IP 패킷
  * 출발지 IP, 목적지 IP, 기타..

* TCP
  * 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증

TCP 특징
1. 연결지향 : 연결됐는지 확인 (TCP 3 way handshake)
2. 데이터 전달 보증 : 중간에 누락됐는지를 알 수 있음
3. 순서 보장
4. 신뢰할 수 있는 프로토콜

* TCP 3 way handshake
![image](https://user-images.githubusercontent.com/97269799/224468339-063e3620-ec1a-4a4a-bca5-5559c4259c6c.png)
위와 같이 3번 주고 받음
`SYN` : 접속 요청
`ACK` : 요청 수락

UDP 특징
* TCP 에 비해 거의 기능이 없음
* 몹시 단순하기에 속도가 빠르다. 
* IP 와 거의 같다. +PORT + 체크섬 정도만 추가
* 애플리케이션에서 추가 작업 필요

PORT
* PORT : 내가 해당 IP에 도착하여 해당 서버를 만났을때 이 서버에서 돌아가고 있는 애플리케이션이 2개 이상이라면 이 중 어떤 애플리케이션에 데이터를 전송해야 할까? 를 해결해줌 
* 0 ~ 65535 할당 가능
* 0 ~ 1023: 잘 알려진 포트이기에 사용하지 않는 것을 추천
  * FTP - 20, 21
  * TELNET - 23
  * HTTP - 80
  * HTTPS - 443

### DNS
* IP는 변경될 수 있고 어렵고 가독성이 떨어지기 때문에 DNS 사용
* 일종의 전화번호부와 같으며 도메인 명을 IP 주소로 변환한다. 


## URI 
![image](https://user-images.githubusercontent.com/97269799/224469060-c6fa2981-f43e-47b5-bb05-7e7f29403aab.png)
* Uniform:리소스를 식별하는 통일된 방식
* Resource: 자원, URI로 식별할 수 있는 모든 것(제한이 없다.)
* Identifier: 다른 항목과 구분하는데 필요한 정보

### URL 분석
`scheme://[userinfo@]host[:port][/port][/path][?query][#fragment]`

`https://google.com/search?q=hello&hl=ko`
* 스키마 : 주로 프로토콜 사용
  * 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙(http, https ftp 등)
* http:80포트 / https:443포트 / 
* https 를 적으면 뒤에 port는 생략 가능
* userinfo는 거의 사용 x
* host : 보통 도메인 명 (naver.com)
* query : key=value 형태 / ?로 시작 / &로 추가 가능

### 웹 브라우저 요청 흐름
![image](https://user-images.githubusercontent.com/97269799/224471513-97e2dfef-a0b1-4934-badc-04503686221d.png)

1. 웹 브라우저가 HTTP 메세지를 생성
2. SOCKET 라이브러리를 통해 TCP/IP계층에 전달한다. 이전단계에서 찾은 IP와 PORT정보를 가지고 SYN, SYN+ACK, ACK 과정을 통해 서버와 연결을 한다. 연결이 성공되면 TCP/IP 계층으로 데이터를 전달한다.
3. TCP/IP 패킷을 생성한다. HTTP 메세지도 포함된다. 
4. 서버는 패킷이 도착하면 패킷의 내부 HTTP 메서드를 해석해서 정보에 맞는 동작을 한다.
5. 서버에서 HTTP 응답 메세지를 생성한다. (HTML 데이터)
6. 클라이언트에서는 응답메세지를 받아 맞는 동작(ex: 렌더링)을 한다. 


## HTTP
HTTP(Hyper Text Transfer Protocol) : 문서간에 링크를 통해 연결할 수 있는 프로토콜
* HTML, TEXT
* IMAGE, 음성, 영상, 파일
* JSON, XML(API)
* 거의 모든 형태의 데이터가 전송 가능하다.
* 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.

## HTTP 특징
* 클라이언트 서버 구조로 동작한다. 
* 무상태 프로토콜(stateless), 비연결성
* HTTP 메세지를 통해서 통신을 한다(송/수신 모두)
* 단순함, 확장 가능

> 클라이언트 서버 구조
* request / response 구조
* 클라이언트는 서버에 요청을 보내고, 응답을 대기
* 서버가 요청에 대한 결과를 만들어서 응답

> sateless
* 서버가 클라이언트의 상태를 보존하지 않는다. 그렇기에 매번 요청에 모든 상태값들을 전달해줘야 한다. 
* 상태 유지: 중간에 서버가 변경되면 안된다. (만약 서버가 변경되야 한다면 상태 정보를 전부 다른 서버에게 미리 알려줘야 한다.)
* 무상태: 중간에 서버가 변경되도 된다.
* 클라이언트가 폭증해도 **서버를 대거 늘릴 수 있다.**
* 무상태는 응답 서버를 변경하기가 쉽기에 **서버 증설**이 쉽다. 


* 무상태의 한계
 * 로그인한 사용자의 경우 해당 상태를 서버에 유지해야한다.
 * 일반적으로 브라우저 쿠키와 서버 세션등을 사용해 상태를 유지한다.
 * 상태 유지는 최소한으로만 사용한다.
 * 보내야 하는 데이터가 너무 많다. ⇒ 매번 요청에 필요한 데이터를 전부 작성해야 하기 때문.

> 비연결성
* 클라이언트별로 서버와 연결을 유지하지 않을경우 필요할때만 연결을 하며 그외에는 연결을 유지하지 않기 때문에 서버에서 사용해야 하는 자원이 훨씬 줄어든다. 
* HTTP는 기본이 연결을 유지하지 않는 모델이다.
* 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
* 1시간동안 수천명 이상이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 적다. 
  * EX: 웹 브라우저 검색페이지에서 검색버튼만 연타하면서 이용하지는 않는다.
* 서버 자원을 매우 효율적으로 사용할 수 있다.

* 비연결성의 한계
  * TCP/IP 연결을 새로 맺어야 한다. - 3 way handshake 시간 추가
    * 지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결한다.
![image](https://user-images.githubusercontent.com/97269799/224472558-ba8bda2d-c6a1-4364-b076-fe8bce86f721.png)


**스테이스리스를 기억하자.**
실무상황에서 특정 시간에 발생하는 대용량 트래픽에 대해서 대응해야 하는 경우가 생긴다.
(Ex: 선착순 이벤트, 명절 KTX예약, 개강전 수업 등록)

이럴 경우 수천, 수만명 이상이 동시에 접속을 하면서 서버에 과부하가 걸리는 경우가 있는데,  이 경우 무상태 페이지를 활용해 페이지 접속인원을 분산해서 대용량 트래픽을 분산시키면 좋다


## HTTP 메시지
* 요청 메시지
![image](https://user-images.githubusercontent.com/97269799/224472649-e02d557e-c117-4634-a48b-e4ee953aaa65.png)

* 응답 메시지
![image](https://user-images.githubusercontent.com/97269799/224472669-d4888ed4-922f-44e5-8768-451fe2c5b5bc.png)

HTTP 헤더엔 HTTP 전송에 필요한 모든 부가 정보를 담고 있음.
HTTP 메시지 바디엔 실제 전송할 데이터 (html문서, json, 이미지..)


## HTTP 메서드
* 회원 목록 조회 : /members
* 회원 조회: /members/{id}
* 회원 등록: /members/{id}
* 회원 수정: /members/{id}
* 회원 삭제: /members/{id}
참고: 계층 구조상 상위를 컬렉션으로 보고 복수산어를 사용하기를 권장한다(member→ members)

### HTTP 메서드 종류
* GET: 리소스 조회
  * 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해 전달한다.
* POST: 요청 데이터 처리, 주로 등록에 사용한다.
  * 메시지 바디를 통해 서버로 요청데이터를 전달한다.
  * 새 리소스 생성(등록)
  * 요청 데이터 처리
* PUT: 리소스를 대체하며 해당 리소스가 없으면 생성한다.
  * 리소스를 대체하는 메서드로 리소스가 있을경우 대체하고 없을 경우 생성한다. (Overwrite)
  * 클라이언트가 리소스를 식별한다 (ex. 게시글 100번째에 put 하겠다.)
  * **기존의 리소스를 완전히 대체함.**
* PATCH: 리소스 부분 변경
  * put의 리소스를 완전히 대체하는 기능과 다르게 리소스를 일부 변경함. 
* DELETE: 리소스 삭제

### HTTP 메서드의 속성
![image](https://user-images.githubusercontent.com/97269799/224476459-71295ed1-8795-48ca-b398-52b48b106fda.png)

* 안전(Safe Methods)
  * 호출해도 리소스가 변경되지 않는다. 
  * GET같은경우에 조회만해서 리소스를 변경하지 않기에 안전하다. 
  * POST,PUT,DELETE,PATCH같은경우 리소스를 변경하기에 안전하지 않다.
* 멱등
  * GET: 몇 번을 조회하더라도 같은 결과가 조회된다. ⇒ 회원 정보를 몇번을 조회한다고 정보가 달라지지 않는다. 
  * PUT: 결과를 대체한다. 따라서 같은 요청을 여러번해도 최종 결과는 같다.
  * DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
  * POST: **멱등이 아니다.** 두 번 호출하면 에러가 발생할수 있다. ⇒ POST로 주문을 두 번 호출하면 결제가 중복될 수 있다. 
  * 멱등의 활용
    * 서버가 TIMEOUT 등으로 정상 응답을 하지 못했을때 클라이언트에서 **같은 요청을 해도 되는가에 대한 판단근거**가 된다. 
* **캐시가능**(Cacheable Methods)
  * 응답 결과 리소스를 캐시해서 사용 가능
  * 실제로는 GET, HEAD 정도만 캐시로 사용한다.



## 클라이언트에서 서버로 데이터 전송

* 쿼리 파라미터를 통한 데이터 전송 
  * :GET 에서 많이 사용하고 정렬필터나 검색어를 사용할 때 이 쿼리 파라미터를 많이 사용한다. 
* 메시지 바디를 통한 데이터 전송
  * : POST, PUT, PATCH에서 사용되며 회원 가입, 상품 주문과 같이 리소스를 등록하거나 변경하는데에 사용한다. 

클라이언트에서 서버로 데이터를 전송하는 4가지 상황
1. 정적 데이터 조회
2. 동적 데이터 조회
3. HTML Form 을 통한 데이터 전송
![image](https://user-images.githubusercontent.com/97269799/224477275-e059016e-9458-498e-9159-aad8b875eb33.png)
   - multipart form data
![image](https://user-images.githubusercontent.com/97269799/224477329-a7638c6f-42e8-4193-a6bb-9adc1fb1058d.png)
multipart/form-data 형식이라면 HTTP 메세지에 임의의 구분자(boundary=——-XXX) 가 Form 데이터간 구분을 지어준다. 
4. HTTP API를 통한 데이터 전송
  - Content-Type: application/json을 주로 사용(사실상 표준)

## HTTP API 설계 에시
> POST 신규 등록
![image](https://user-images.githubusercontent.com/97269799/224477748-7d51de79-1544-468d-a735-8f86e5d51d57.png)

* POST - 신규 자원 등록 특징
  * 클라이언트는 등록될 리소스의 URI를 모른다. 
  * 서버가 새로 등록된 리소스 URI를 생성해준다.
  * `컬랙션` 이라고 함


> PUT 신규 등록 (파일 같은 경우 put 을 씀)

![image](https://user-images.githubusercontent.com/97269799/224478041-9e1435bb-13dd-4a19-87b9-b1cfd2be411d.png)


* put - 신규 자원 등록 특징
  * 이땐 클라이언트가 리소스 URI 를 알고 있어야 한다.
    * /files/{filename} -> put
  * `스토어` 라고 

> HTML FORM 사용

![image](https://user-images.githubusercontent.com/97269799/224478231-f36a9412-635b-417e-8422-b0f0c60cfec6.png)
* post 의 /new, /edit, /delete 같은 걸 컨트롤 URI 라고 함

### 참고하면 좋은 URI 설계 개념

* 문서(document)
  * 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
    * 예) /members/100, /file/star.jpg
* 컬렉션(collection)
  * 서버가 관리하는 리소스 디렉토리
  * 서버가 리소스의 URI를 생성하고 관리
    * 예) /members
* 스토어(store)
  * 클라이언트가 관리하는 자원 저장소
  * 클라이언트가 리소스의 URI를 알고 관리
    * 예) /files
* 컨트롤러(controller), 컨트롤 URI
  * 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
  * 동사를 사용한다.
    *예) /members/{id}/delete
* IP 패킷
  * 출발지 IP, 목적지 IP, 기타..



## HTTP 상태코드
> 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

* 1xx(Informational): 요청이 수신되어 처리중
* 2xx(Successful):요청 정상 처리
* 3xx(Redirection):요청을 완료하려면 추가 행동이 필요
* 4xx(Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음.
* 5xx(Server Error):서버 오류, 서버가 정상 요청을 처리하지 못함

> 2xx 성공
* 200 OK
* 201 Created
  * 요청을 성공해서 새로운 리소스가 생성된 경우의 상태코드
  * 생성된 리소스는 응답의 Location 헤더 피드로 식별
* 202 Accepted
  * 요청이 접수되었으나 처리가 완료되지 않은경우로 배치 처리 같은 곳에서 사용
* 204 No Content
  * 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없는 경우

> 3xx - 리다이렉션
* 바뀌기 전 주소로 클라이언트가 요청하면 새 주소로 리다이렉
1. 클라이언트에서 /event 를 요청.
2. 서버에서는 이제 /new-event로 경로가 변경되었다고 응답
3. 클라이언트에서는 자동 리다이렉트를 Location에 있는 /new-event로 수행
4. 서버는 요청받은 경로인 /new-event에 대해서 정상 응답.

* 리다이렉션 종류
1. 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동
( 예) /members → /users
* 예) /event → /new-event
2. 일시 리다이렉션 - 일시적인 변경
* 주문 완료 후 주문 내역 화면으로 이동
PRG: POST/Redirect/Get
3. 특수 리다이렉션
* 결과 대신 캐시를 사용

### 영구 리다이렉션
`301`, `308`

* 리소스의 URI가 영구적으로 이동
* 301로 요청시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다 (MAY) 
* 308로 요청시 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST로 유지)
  * 실무에서는 경로가 바뀌면서 리다이렉션하는 경우 왠만해서는 POST사용을 유지할 필요가 없다. 페이지가 바뀌면서 필요한 파라미터나 정보들도 바뀌기 때문이다 그렇기에 대부분 308보다는 **301을 사용**한다. 

### 일시적인 리다이렉션
`302`, `307`, `303`

* 302로 요청시 요청 메서드가 대부분 get으로 변함 **302를 제일 많이 씀. 302 쓰면 **
* 307로 요청시 요청 메서드와 본문 유지
* 303로 요청시 무조건 요청 메서드가 get으로 변경

PRG: Post/Redirect/Get
일시적인 리다이렉션
만약 POST로 주문후에 웹 브라우저를 새로고침하면 어떻게 될까? 이 양식을 다시 보내겠냐며 경고창이 뜰 수 있지만, 일단 다시 요청할경우 중복으로 주문이 들어갈 수 있다. 
![image](https://user-images.githubusercontent.com/97269799/224480098-3b9fb727-721c-4e54-b57e-79ac9ad86f44.png)

### 기타 리다이렉션
`304`

* 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다. 
* 304 응답은 응답에 메세지 바디를 포함하면 안된다.(로컬 캐시를 사용해야 하기에)


> 4xx
* 클라이언트 오류
* 400 Bad Request
  * 요청 구문, 메시지 등등에서 문제가 있을 때 발생
  * 클라이언트는 요청 내용을 재검토하고 수정해서 보내야 한다. 
  * 서버단에서 스펙에 안맞는 요청이 오면 철저하게 검증해서 400 상태코드를 반환해서 해당 케이스에 **500 에러로 서버 문제로 넘어가지 않아야 한다.**
* 401 Unauthorized 
  * 인증(Authentication)되지 않음
* 403 Forbidden
  * 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
  * 일반 사용자가 운영자 등급의 리소스에 접근하고자 할 때 발생
* 404 Not Found
  * 요청 리소스를 찾을 수 없을때 발생

> 5xx
* 서버 오류
* 500 Internal Server Error
  * 서버 내부 문제로 오류가 발생
  * 애매하면 모두 500 오류를 낸다. 
* 503 Service Unavailable
  * 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음.
  * Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수 있다. 


## HTTP 헤더
![image](https://user-images.githubusercontent.com/97269799/224491152-e112d0ec-8fcf-4b76-bd67-ca1e0a8ac207.png)
* 메시지 본문을 통해 표현 데이터 전달
* 메세지 본문 = Payload
* 표현은 요청이나 응답에서 전달할 실제 데이터
* 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
⇒ 데이터 유형(html, json), 데이터 길이, 압축 정보 등


### 표현
* 회원이라는 리소스가 있을 때 이를 HTML 혹은 JSON으로 전달할꺼야 라는 클라이언트와 서버간에 송/수신할 때 이 리소스를 무엇으로 표현할지 알려주고, 표현한다.
* `Content-Type`: 표현 데이터의 형식
  * text/html; charset=utf-8
  * application/json (기본이 utf-8)
  * image/png
* `Content-Encoding`: 표현 데이터의 압축 방식
  * 표현 데이터를 압축하기 위해 사용한다.
* `Content-Language`: 표현 데이터의 자연 언어
* `Content-Length`: 표현 데이터의 길이


### 협상(콘텐츠 네고시에이션)
클라이언트가 선호하는 표현 요청

클라이언트가 원하는 우선순위대로 맞춰서 서버에서 되는대로 표현 데이터를 만들어 주는 것.  클라이언트에서 요청시에 작성하는 것이기에 요청에만 사용한다. 

> 예시
* Accept-Language 적용 전
![image](https://user-images.githubusercontent.com/97269799/224491472-294413b4-3f50-4995-9cc3-f7e3bc0f8a27.png)
* Accept-Language 적용 후
![image](https://user-images.githubusercontent.com/97269799/224491487-69d094fc-a521-4eb7-8f36-a1bf69f47609.png)
* 우선순위도 정할 수 있다
  * `Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7`
  * 0~1, 1에 가까울수록(클수록) 높은 우선순위를 가진다. 

### 전송 방식
1. 단순 전송
* Content-Length
  * 메세지 바디의 길이를 다 알고있을 때 사용. 
  * 한번에 요청하고 응답한다. 

2. 압축 전송
* Content-Encoding
  * Content-Encoding이라는 항목을 헤더에 넣어서 어떻게 압축했는지 알려줘야 한다. 

3. 분할 전송
* Transfer-Encoding
  * ![image](https://user-images.githubusercontent.com/97269799/224491890-4523a267-43b1-48fc-9906-138059854538.png)
  * 서버에서 클라이언트로 응답 메세지를 특정 단위로 나눠서 보낸다.
  * 용량이 매우 큰 응답을 할 때 분할 전송으로 전송되는대로 표현을 하는 방식이다. 
  * 이때는 Content-Length를 넣으면 안된다.(길이를 예측할 수 없기 때문)

4. 범위 전송
* Range, Content-Range
  * 이미지와 같이 용량이 큰 데이터를 받을 때 중간에 전송이 끊겼을 경우 범위를 지정해서 요청하면 매번 끊길때마다 새로 받을 필요없이 특정 범위부터 응답해서 속도를 높힐 수 있다. 


### 일반 정보
* From
  * 유저 에이전트의 이메일 정보
  * 일반적으로 잘 사용되지는 않는다.
  * 검색 엔진 같은 곳에서, 주로 사용

* Referer (많이 사용)
  * 이전 웹 페이지 주소
  * 현재 요청된 페이지의 이전 웹 페이지 주소
  * A페이지에서 B페이지로 이동하면 B를 요청할 때 Referer: A를 포함해서 요청한다.
  * Referer를 사용해서 유입 경로 분석이 가능하다. (어느 사이트를 통해 우리 사이트를 방문했는지 알 수 있음)

* User-Agent
  * 유저 에이전트 애플리케이션 정보
  * 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능하다
  * 통계 정보

* Server
  * 요청을 처리하는 ORIGIN서버의 소프트웨어 정보
  * 참고: HTTP요청을 보내면 여러 프록시 서버를 거치게되는데, 실제로 내 요청을 받고 응답을 해주는 엔드포인트 서버를 ORIGIN 서버라 한다.

* Date
  * 메세지가 발생한 날짜와 시간

### 특별한 정보
* HOST (매우중요)
  * 요청에서 사용
  * 필수값
  * ![image](https://user-images.githubusercontent.com/97269799/224492298-a8eba2c7-c6d5-4306-899f-5c7ea2e9154f.png)
  * 헤더 정보에 HOST를 추가함으로써 서버에서 어느 도메인으로 들어가야할지 알 수 있다. 

* Location
  * 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다

* Allow
  * 허용 가능한 HTTP 메서드
  * 경로는 존재하지만 지원하는 HTTP 메서드가 한정적이기에 해당 헤더를 넣어주면 클라이언트에서는 서버에서 해당 경로가 지원하는 HTTP 메서드가 무엇인지 알 수 있다. 
  * (실제로 사용되는 빈도수는 높지 않다.)

* Retry-After
  * 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  * 사용하기가 쉽지가 않다.(예측하기 힘듬) 

### 인증

* Authorization
클라이언트 인증 정보를 서버에 전달
  * Authorization: BASIC xxxxxxxxxxxxxxxxxx
  * 인증 방식은 OAuth, OAuth2, SNS로그인 등 다양한데, 그런 방식별로 들어가야하는 값이 다르다. 
  * 인증 메커니즘과는 상관없이 헤더를 제공하는 것으로 인증과 관련된 값을 넣어주면 된다.
* WWW-Authentication
  * 리소스 접근시 필요한 인증 방법 정의
  * 리소스 접근시 필요한 인증 방법 정의
  * 401 Unauthorized 응답과 함꼐 사용한다.
  * WW-Authentication: Newauth realm="apps", type=1,title="Login to \"apps\"", Basic realm="simple"
  * ⇒ 위와같은 방식으로 어떻게 인증을 해야할지를 정의해 알려준다. 

### 쿠키 (중요)
HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은데이터 조각으로 브라우저는 이 데이터 조각들을 저장해 놓았다가 동일한 서버에 재 요청시 저장된 데이터를 함께 전송한다. 

* Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달한다.

* Stateless
  * 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
  * 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
  * 클라이언트와 서버는 서로 상태를 유지하지 않는다.

> http는 무상태 프로토콜이기 때문에 클라이언트가 로그인 한 사람인지 아닌지를 판단할 수 없다. 이때 쿠키 사용

![image](https://user-images.githubusercontent.com/97269799/224492961-b202ff3b-1bac-434c-9296-2f6ca18442bd.png)
* 클라이언트에서 로그인을 요청하며 데이터를 보내면 서버에서는 Set-Cookie로 로그인 정보를 담아 응답한다. 
* 웹브라우저는 내장된 쿠키 저장소에 Set-Cookie에 있는 정보를 저장한다. 
* 그래서 로그인 이후 welcome 페이지에 접근하면 쿠키를 조회해서 쿠키값을 Cookie에 담아서 보낸다.
![image](https://user-images.githubusercontent.com/97269799/224492987-2e456461-fd39-40d1-be4d-d6258b642416.png)


**쿠키의 사용처 및 사용시 주의점**
* 사용처
  * 사용자 로그인 세션 관리
  * 광고 정보 트래킹
* 쿠키 정보는 항상 서버에 전송된다.
  * 네트워크 트래픽을 추가적으로 유발한다.
  * 최소한의 정보만 사용해야 한다(세션, id, 인증 토큰(OAuth))
  * 서버에 전송하지 않고 웹 브라우저 내부에 데이터를 저장하고 싶은 경우 웹스토리지를 사용
* 주의점
  * 보안에 민감한 데이터는 저장하면 안된다.
  * ⇒ 주민번호, 신용카드 번호 등


* 쿠키의 생명 주기
  * 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지된다.
  * 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지된다. 

* 쿠키 도메인 지정
* 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함
  * ⇒ domain=example.org로 지정해서 쿠키를 생성하면
    * ⇒ example.org → 쿠키 접근가능
    * ⇒dev.example.org → 쿠키접근 가능
* 생략: 현재 문서 기준 도메인만 적용
  * ⇒ example.org 에서 쿠키를 생성하고 domain 지정을 생략하면
    * ⇒ example.org 에서만 쿠키 접근이 가능하다.
    * ⇒ dev.example.org는 쿠키 접근이 불가하다.


* 쿠키 경로 지정
  * 작성한 경로를 포함한 하위 경로 페이지에서만 쿠키 접근이 가능하다. 
  * 일반적으로 path=/ 루트로 지정한다

* 쿠키 보안 `Secure`, `HttpOnly`, `SameSite`


## 캐시와 조건부 요청

* 캐시를 적용하면
* ![image](https://user-images.githubusercontent.com/97269799/224493537-44c1fcf7-434a-4ea4-91cb-960ce35ff9cd.png)
* 헤더에 cache-controll 속성을 넣어주어 캐시가 유효한 시간을 넣어준다. 
* 위에서는 60초로 설정해 60초 동안은 해당 캐시가 유효하다는 의미다. 그럼 브라우저 캐시에 응답 결과를 저장하며 60초간 유효하다.


* 두 번째 요청할때는 우선 캐시를 조회한다.
* 캐시가 존재하고 아직 60초 이내이기에 유효한 캐시가 있어서 해당 캐시에서 자료를 가져온다. 
