스프링 프레임워크
- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트
- 웹 기술 : 스프링 MVC
- 데이터 접근 기술 : ORM 지원, 트랜잭션, JDBC
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원


스프링 부트
- 스프링을 편리하게 사용할 수 있도록 지원
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공 (라이브러리 사용 편리)
- 스프링과 외부 라이브러리 자동 구성 (버전 이슈 해결)


스프링의 진짜 핵심
- 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크


객체지향 언어의 특징
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체" 들의 모임으로 파악하고자 하는 것
- 각각의 객체는 메세지를 주고받고, 데이터를 처리할 수 있다.
- 이는 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 개발에 많이 사용된다. -> 다형성


스프링과 객체지향
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 제어의 역전(IoC), 의존관계 주입(DI) 는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.


좋은 객체 지향 설계의 5가지 원칙 (SOLID)
SRP : 단일 책임 원칙
OCP : 개방-폐쇄 원칙
LSP : 리스코프 치환 원칙
ISP : 인터페이스 분리 원칙
DIP : 의존관계 역전 원칙


OCP
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. (의존관게 주입을 통해 스프링에선 OCP를 지킬 수 있다)

DIP
- 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻


AppConfig
- 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성 하고 연결 하는 책임을 가지는 별도의 클래스


<제어의 역전>
AppConfig가 프로그램의 제어 흐름을 가져가는 것. 
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 IoC(제어의 역전) 이라고 한다.

cf: 프레임워크가 내 코드를 제어하면 프레임워크, 반면에 내가 작성한 코드를 직접 제어한다면 라이브러리


<의존관계 주입 DI>
의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계로 분리해서 생각해야 함
의존관계 주입을 사용하면 정적인 클라이언트 코드를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.


스프링 컨테이너에서 memberService 찾아오기
ApplicationContext applicationCOntext = new AnnotationConfigApplicationContext(AppConfig.class)
MemberService memberService = application.getBean("memberService", memberService.class)
-> 스프링 컨테이너는 @Configuration이 붙은 클래스를 설정 정보로 사용, 이때 @Bean이 붙은 메소드 들을 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록


웹 애플리케이션과 싱글톤
- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다. 따라서 기존의 AppConfig를 사용하면 요청할 때마다 새로운 객체를 만든다.
- 이는 메모리 낭비가 심하다
-> 해결방안 : 해당 객체는 딱 1개만 생성되고, 공유하도록 설계 -> 싱글톤 패턴


<싱글톤 패턴>
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- static을 사용해서 하나를 공유, private 생성자를 만들어 새로 객체를 만드는것을 막음

<싱글톤 컨테이너>
싱글톤 패턴을 쓰는 컨테이너

- 주의점
	- 무상태로 설계해야 한다.
	- 특정 클라이언트에 의존적인 필드가 있으면 안 된다.
	- 가급적 읽기만 가능해야 한다.
	- 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.



@Configuration 과 싱글톤
스프링이 CGLIB 이라는 바이트코드 조작 라이브러리를 이용하여 임의의 다른 클래스를 만들어 스프링 빈으로 등록함
	결론 : @Configuration 때문에 싱글톤이 보장된다. (여러번 객체를 new 호출해도..)
	        @Configuration 없이 @Bean만 붙이면 싱글톤이 보장되지 않음.


<@ComponentScan>
- @Component 애너테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- @Autowired 를 이용하여 의존관계 주입을 해줌
- basePackaes : 탐색(스캔) 할 위치를 정함, 정한 위치로 부터 하위폴더를 전부 뒤짐
- 권장하는 방법 : 탐색할 위치를 따로 정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것.

@Component : 컴포넌트 스캔에서 사용
@Controller : 스프링 MVC 컨트롤러에서 사용
@Service : 스프링 비즈니스 로직에서 사용 / 서비스는 특별한 처리를 하지 않는다. 관례
@Repository : 스프링 데이터 접근 계층에서 사용
@Configuration : 스프링 설정 정보에서 사용

필터기능
- includeFilters
- excludeFilters


<생성자 주입>
- 생성자 호출시점에 딱 1번만 호출됨 (불변, 필수)
- 생성자가 하나일땐 @Autowired가 없어도 의존관계주입이 가능하다


@Autowired 빈 조회 매커니즘
1. 타입이 같은 빈을 조회
2. 이때 빈이 여러개 조회되면 필드 이름, 파라미터 이름으로 빈 매칭


<빈 생명 주기>
데이터베이스 커넥션 풀 처럼 애플리케이션 시작 시점에 미리 연결을 하거나 애플리케이션이 종료될때 연결을 종료하는 작업을 진행하려면 객체의 초기화와 종료 작업이 필요
- 스프링 빈의 이벤트 라이프사이클
	스프링컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

콜백 하는 방법
@PostConstruct, @PreDestroy


<빈 스코프>
싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
프로토타입 : 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
웹 관련 스코프
	- request : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
	- session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다. (로그인에서 많이 쓰임)

프로토타입 스코프
- 프로토 타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.
- 종료 메소드는 따로 호출되지 않는다
동작순서
1. 프로토 타입 스코프의 빈을 스프링 컨테이너에 요청
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.


싱글톤이 프로토 타입을 주입 받았을 경우 문제점이 발생한다.
- 싱글톤 빈이 만들어지면서 프로토 타입 빈이 주입됨. 따라서 새로운 프로토 타입 빈을 만드는 것이 아님
- 해결법 : Provider을 사용
		프로토 타입을 주입 받는 대신
		private ObjectProvider<PrototypeBean> prototypeBeanProvider 을 주입받고
		프로토 타입이 필요할떄마다 prototypeBeanProvider.getObject(); 로 프로토타입 빈을 가져옴
- ObjectProvider는 딱 필요한 DL(디펜던시 룩업) 정도의 기능을 제공
- ObjectProvicer 는 스프링에 의존적 But 의존적이지 않은 기능도 있음
- javax.inject 의 Provider 을 사용


<웹스코프>
웹 스코프는 웹 환경에서만 동작
프로토 타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리
-request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리
-session : HTTP Session 과 동일한 생명주기를 가지는 스코프

<request 스코프>
- 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어려움. 이때 사용하기 좋은 스코프
- 여러 요청이 와도 요청별로 관리 해줌

- 문제점 : 스프링 빈을 등록할 때 request 스코프 빈은 요청이 와야 생성되기 때문에 의존관계 주입 받는 시점에서 오류 발생
- 해결책 : @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS) 을 사용하면
	     의존관계 주입 받을 때 가자 객체를 주입하여 오류 해결
